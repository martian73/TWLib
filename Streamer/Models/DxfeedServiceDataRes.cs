/*   This file is part of TWLib.
 *
 *    TWLib is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    TWLib is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with TWLib.  If not, see <https://www.gnu.org/licenses/>.
 ******************************************************************************
 *
 *    Project available from here: https://github.com/martian73/TWLib.git
 ******************************************************************************
 */
// Generated by Xamasoft JSON Class Generator
// http://www.xamasoft.com/json-class-generator


using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Runtime.Serialization;

namespace TWLib.Streamer.Models
{
    public class DxfeedServiceDataRes
    {
        [JsonProperty("data")]
        public IList<dynamic> Data { get; set; }

        [JsonProperty("channel")]
        public string Channel { get; set; }

        public ServiceData[] ServiceData
        {
            // Example:
            //Data[0][0] == "Greeks"
            //Data[0][1] == Array of Greeks Headers
            //Data[1] ==  Array of Greeks Values

            get
            {
                string type;
                dynamic data;

                List<ServiceData> list = new List<ServiceData>();

                // No headers
                if (Data[0].GetType() == typeof(System.String))
                {
                    type = Data[0].ToString();
                    data = Data[1];
                }
                else // With headers
                {
                    type = Data[0][0].ToString();
                    string[] headers = (Data[0][1]).ToObject<string[]>();
                    data = Data[1];

                    if (type.CompareTo("Quote") == 0)
                    {
                        Quote.Headers = headers;
                    }
                    if (type.CompareTo("Trade") == 0)
                    {
                        Trade.Headers = headers;
                    }
                    if (type.CompareTo("Summary") == 0)
                    {
                        Summary.Headers = headers;
                    }
                    if (type.CompareTo("TheoPrice") == 0)
                    {
                        TheoPrice.Headers = headers;
                    }
                    if (type.CompareTo("Profile") == 0)
                    {
                        Profile.Headers = headers;
                    }
                    if (type.CompareTo("Greeks") == 0)
                    {
                        Greeks.Headers = headers;
                    }
                    //if (type.CompareTo("order") == 0)
                    //{
                    //    Order.Headers = headers;
                    //}
                }
                
                dynamic var = new ExpandoObject();
                var dict = (IDictionary<string, object>)var;
                int headerCount = 0;
                List<string> headerList = new List<string>();

                if (type.CompareTo("Quote") == 0)
                {
                    headerCount = Quote.Headers.Length;
                    for (int idx = 0; idx < data.Count; idx += headerCount)
                    {
                        for (int hdr = 0; hdr < headerCount; ++hdr)
                        {
                            dict.Add(Quote.Headers[hdr], data[idx + hdr]);
                        }

                        Quote quote = JsonConvert.DeserializeObject<Quote>(JsonConvert.SerializeObject(dict));
                        dict.Clear();
                        list.Add(quote);
                    }
                    return list.ToArray();
                }

                if (type.CompareTo("Trade") == 0)
                {
                    headerCount = Trade.Headers.Length;
                    for (int idx = 0; idx < data.Count; idx += headerCount)
                    {
                        for (int hdr = 0; hdr < headerCount; ++hdr)
                        {
                            dict.Add(Trade.Headers[hdr], data[idx + hdr]);
                        }

                        Trade trade = JsonConvert.DeserializeObject<Trade>(JsonConvert.SerializeObject(dict));
                        dict.Clear();
                        list.Add(trade);
                    }
                    return list.ToArray();
                }

                if (type.CompareTo("Summary") == 0)
                {
                    headerCount = Summary.Headers.Length;
                    for (int idx = 0; idx < data.Count; idx += headerCount)
                    {
                        for (int hdr = 0; hdr < headerCount; ++hdr)
                        {
                            dict.Add(Summary.Headers[hdr], data[idx + hdr]);
                        }
                        
                        Summary sum = JsonConvert.DeserializeObject<Summary>(JsonConvert.SerializeObject(dict));
                        dict.Clear();
                        list.Add(sum);
                    }
                    return list.ToArray();
                }

                if (type.CompareTo("Greeks") == 0)
                {
                    headerCount = Greeks.Headers.Length;
                    for (int idx = 0; idx < data.Count; idx += headerCount)
                    {
                        for (int hdr = 0; hdr < headerCount; ++hdr)
                        {
                            dict.Add(Greeks.Headers[hdr], data[idx + hdr]);
                        }

                        Greeks greek = JsonConvert.DeserializeObject<Greeks>(JsonConvert.SerializeObject(dict));
                        dict.Clear();
                        list.Add(greek);
                    }
                    return list.ToArray();
                }

                if (type.CompareTo("TheoPrice") == 0)
                {
                    headerCount = TheoPrice.Headers.Length;
                    for (int idx = 0; idx < data.Count; idx += headerCount)
                    {
                        for (int hdr = 0; hdr < headerCount; ++hdr)
                        {
                            dict.Add(TheoPrice.Headers[hdr], data[idx + hdr]);
                        }

                        TheoPrice tp = JsonConvert.DeserializeObject<TheoPrice>(JsonConvert.SerializeObject(dict));
                        dict.Clear();
                        list.Add(tp);
                    }
                    return list.ToArray();
                }

                if (type.CompareTo("Profile") == 0)
                {
                    headerCount = Profile.Headers.Length;
                    for (int idx = 0; idx < data.Count; idx += headerCount)
                    {
                        for (int hdr = 0; hdr < headerCount; ++hdr)
                        {
                            dict.Add(Profile.Headers[hdr], data[idx + hdr]);
                        }

                        Profile prof = JsonConvert.DeserializeObject<Profile>(JsonConvert.SerializeObject(dict));
                        dict.Clear();
                        list.Add(prof);
                    }
                    return list.ToArray();
                }

                Console.WriteLine(JsonConvert.SerializeObject(Data));
                Console.WriteLine("Unsupported data: ");

                return null;
            }
        }
    }
}

